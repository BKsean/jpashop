프로젝트 설정
라이브러리 설정
뷰설정 thymleaf
DB설정
쿼리 파라미터 남기기

엔티티에서는 가급적 setter를 사용하지 말자
모든 연관관계는 지연로딩으로 설정
컬렉션은 필드에서 초기화 하자
*컬렉션은 영속하면 JPA에서 관리하기 쉽도록 타입을 변경한다 이후 컬렉션을 변경하면 JPA에서 관리하기 어렵기 때문에 처음 초기화후 변경 하지 말자

테이블명,컬럼명 생성전략

연관관계 편의 메서드 작성 연관관계 주인쪽에서 작성하는게 편리

테스트 케이스 작성
테스트시 DB를 inMemory로 돌리는 방법

JPQL 동적쿼리등을 위해 querydsl을 사용한대

**변경감지와 병합merge
merge는 쓰지말자
변경감지 방법을 쓰자
merge는 변경감지 방법을 한줄로 간단하게 만들어주는 코드지만 만약 변경하려는 데이터에 null이 있을경우 기존 데이터도 null로 바꾼다.
변경감지는 id값으로 em.find해와서 영속성컨텍스트에 추가한후 그 엔티티를 변경하는 것이다.

*패치조인
*JPA에서 DTO로 바로 결과 받기
1. 일단 엔티티 --> DTO로 변경해서 반환
2. 성능 이슈가 있다면 fetch조인사용
3. 그래도 안된다면 DTO로 원하는 데이터만 select해서 반환
4. 안되면 jpql같은거 사용해서 실제 query를 날려서 조회회
        // orderItem 이 총4개이기 때문에 order도 4개로 중복데이터가 발생한다.  --> 예방 fetch 조인에서 distinct를 적어주면된다 hibernate 6.0에서는 자동 적용된다  1:N fetch조인을 하면 페이징쿼리가 안된다? --> 설정해도 페이징쿼리가 안나간다
        // 패치조인으로 데이터가 중복되는데 거기다가 페이징을 하려고 해서.. --> 페이징처리는 메모리에서 진행
        //*** 컬렉션 패치조인은 1개만 사용할 수 있다. 컬렉션 둘 이상의 페치조인은 사용하면 안된다. 데이터가 부정합해진다.

toone 관계는 페이징쿼리 사용가능

osiv성능최적화
osiv는 spring in view?
JPA의 영속성컨텍스트 가사용하는 커넥션관련된 설정이다.
default는 true인데 이건 사용자 요청이 시작하여 @Transaction시작부터 반환값을 만들어 돌려줄때까지 커넥션을 붙들고 있는것이고
false는 @Transaction안에서만 커넥션을 붙들고 있는 것이다.
성능상 false가 커넥션부족 현상을 예방할 수 있으며 대신 @Transaction안에서 지연로딩 및 패치조인등을 사용하여 객체를 완벽하게 만들어 놓아야한다.

